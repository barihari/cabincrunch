"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/airline-data-converter.ts":
/*!*******************************************!*\
  !*** ./src/lib/airline-data-converter.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToAirlineData: () => (/* binding */ convertToAirlineData)\n/* harmony export */ });\n/* harmony import */ var _amex_partners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./amex-partners */ \"(app-pages-browser)/./src/lib/amex-partners.ts\");\n\n/**\n * Convert existing Amex partner lookup results to the new Airline schema format\n */ function convertToAirlineData(airlineName) {\n    if (!(airlineName === null || airlineName === void 0 ? void 0 : airlineName.trim())) return null;\n    const amexResult = (0,_amex_partners__WEBPACK_IMPORTED_MODULE_0__.lookupAmexPartner)(airlineName);\n    if (!amexResult.isBookable || amexResult.partnerPrograms.length === 0) {\n        return null;\n    }\n    // Determine airline category based on name patterns\n    const getAirlineCategory = (name)=>{\n        const majorUS = [\n            'American Airlines',\n            'Delta Air Lines',\n            'United Airlines',\n            'Southwest Airlines',\n            'JetBlue Airways',\n            'Alaska Airlines'\n        ];\n        const cargo = [\n            'FedEx',\n            'UPS Airlines',\n            'Atlas Air',\n            'Kalitta Air'\n        ];\n        const charter = [\n            'NetJets',\n            'Flexjet',\n            'VistaJet'\n        ];\n        if (majorUS.includes(name)) return \"Major US\";\n        if (cargo.some((c)=>name.includes(c))) return \"Cargo\";\n        if (charter.some((c)=>name.includes(c))) return \"Charter\";\n        // Default to International for most airlines\n        return \"International\";\n    };\n    // Get IATA code mapping (basic implementation)\n    const getIataCode = (name)=>{\n        const iataMap = {\n            'American Airlines': 'AA',\n            'Delta Air Lines': 'DL',\n            'United Airlines': 'UA',\n            'British Airways': 'BA',\n            'Air France': 'AF',\n            'KLM Royal Dutch Airlines': 'KL',\n            'Lufthansa': 'LH',\n            'Singapore Airlines': 'SQ',\n            'Cathay Pacific': 'CX',\n            'Emirates': 'EK',\n            'Qatar Airways': 'QR',\n            'All Nippon Airways': 'NH',\n            'Japan Airlines': 'JL',\n            'Air Canada': 'AC',\n            'Virgin Atlantic': 'VS',\n            'Turkish Airlines': 'TK',\n            'Swiss International Air Lines': 'LX',\n            'Austrian Airlines': 'OS',\n            'Brussels Airlines': 'SN',\n            'Scandinavian Airlines': 'SK',\n            'Finnair': 'AY',\n            'Iberia': 'IB',\n            'Aer Lingus': 'EI',\n            'TAP Air Portugal': 'TP',\n            'LOT Polish Airlines': 'LO',\n            'Czech Airlines': 'OK',\n            'Croatia Airlines': 'OU',\n            'Air China': 'CA',\n            'China Eastern Airlines': 'MU',\n            'China Southern Airlines': 'CZ',\n            'Korean Air': 'KE',\n            'Asiana Airlines': 'OZ',\n            'Thai Airways': 'TG',\n            'Malaysia Airlines': 'MH',\n            'Garuda Indonesia': 'GA',\n            'Philippine Airlines': 'PR',\n            'Vietnam Airlines': 'VN',\n            'Air India': 'AI',\n            'Ethiopian Airlines': 'ET',\n            'Kenya Airways': 'KQ',\n            'South African Airways': 'SA',\n            'EgyptAir': 'MS',\n            'Royal Air Maroc': 'AT',\n            'Royal Jordanian': 'RJ',\n            'Middle East Airlines': 'ME',\n            'Saudia': 'SV',\n            'Etihad Airways': 'EY',\n            'Oman Air': 'WY',\n            'Kuwait Airways': 'KU',\n            'JetBlue Airways': 'B6',\n            'Alaska Airlines': 'AS',\n            'Hawaiian Airlines': 'HA',\n            'Southwest Airlines': 'WN',\n            'Frontier Airlines': 'F9',\n            'Spirit Airlines': 'NK',\n            'Allegiant Air': 'G4',\n            'Sun Country Airlines': 'SY',\n            'Qantas': 'QF',\n            'Virgin Australia': 'VA',\n            'Air New Zealand': 'NZ',\n            'Avianca': 'AV',\n            'LATAM Airlines': 'LA',\n            'Copa Airlines': 'CM',\n            'Aeromexico': 'AM',\n            'WestJet': 'WS'\n        };\n        return iataMap[name];\n    };\n    // Find the preferred partner (prioritize Direct > Alliance > Bilateral)\n    const sortedPartners = [\n        ...amexResult.partnerPrograms\n    ].sort((a, b)=>{\n        const priority = {\n            'Direct': 0,\n            'Alliance': 1,\n            'Bilateral': 2\n        };\n        return priority[a.relationship] - priority[b.relationship];\n    });\n    const preferredPartner = sortedPartners[0];\n    const isDirectPartner = preferredPartner.relationship === 'Direct';\n    // Generate how-to-book steps based on the partner type\n    const generateBookingSteps = (partnerName, relationship, airlineName)=>{\n        const baseSteps = [\n            \"Transfer Amex points to \".concat(partnerName, \" at \").concat(preferredPartner.transferRatio, \" ratio\"),\n            \"Wait for transfer to complete (\".concat(preferredPartner.transferTime, \")\"),\n            \"Log into your \".concat(partnerName, \" account\")\n        ];\n        if (relationship === 'Direct') {\n            return [\n                ...baseSteps,\n                \"Search for \".concat(airlineName, \" flights on the \").concat(partnerName, \" website\"),\n                \"Book using points and pay any taxes/fees with cash\"\n            ];\n        } else if (relationship === 'Alliance') {\n            return [\n                ...baseSteps,\n                \"Search for \".concat(airlineName, \" flights (alliance partner) on the \").concat(partnerName, \" website\"),\n                \"Book the award ticket using points\",\n                \"Pay taxes and fees with cash (may be higher for partner awards)\"\n            ];\n        } else {\n            return [\n                ...baseSteps,\n                \"Search for \".concat(airlineName, \" flights on the \").concat(partnerName, \" website\"),\n                \"Look for partner award availability (may be limited)\",\n                \"Book using points and pay taxes/fees with cash\"\n            ];\n        }\n    };\n    // Generate notes based on common patterns\n    const generateNotes = (partnerName, relationship)=>{\n        const notes = [];\n        if (relationship === 'Alliance') {\n            notes.push(\"Alliance partner bookings may have limited award availability\");\n            notes.push(\"Expect higher taxes and fees compared to direct partner bookings\");\n        }\n        if (relationship === 'Bilateral') {\n            notes.push(\"Bilateral partnership may have restricted routes and availability\");\n        }\n        if (partnerName.includes('British Airways')) {\n            notes.push(\"British Airways uses distance-based pricing - excellent for short flights\");\n            notes.push(\"Low taxes and fees on domestic US flights\");\n        }\n        if (partnerName.includes('Air France') || partnerName.includes('KLM')) {\n            notes.push(\"Flying Blue has dynamic pricing - book early for better rates\");\n        }\n        if (partnerName.includes('Singapore Airlines')) {\n            notes.push(\"KrisFlyer has excellent premium cabin availability\");\n        }\n        if (notes.length === 0) {\n            notes.push(\"Book well in advance for better award availability\");\n        }\n        return notes;\n    };\n    const bookableVia = amexResult.partnerPrograms.map((p)=>p.partnerName);\n    const partnerDetails = amexResult.partnerPrograms.map((p)=>({\n            name: p.partnerName,\n            relationship: p.relationship,\n            transferRatio: p.transferRatio,\n            transferTime: p.transferTime\n        }));\n    const notes = generateNotes(preferredPartner.partnerName, preferredPartner.relationship);\n    return {\n        name: airlineName,\n        iataCode: getIataCode(airlineName),\n        category: getAirlineCategory(airlineName),\n        isDirectPartner,\n        isAllianceBookable: amexResult.partnerPrograms.some((p)=>p.relationship === 'Alliance'),\n        isBilateralBookable: amexResult.partnerPrograms.some((p)=>p.relationship === 'Bilateral'),\n        bookableVia,\n        partnerDetails,\n        preferredPartner: preferredPartner.partnerName,\n        transferRatio: preferredPartner.transferRatio,\n        transferTime: preferredPartner.transferTime,\n        howToBookSteps: generateBookingSteps(preferredPartner.partnerName, preferredPartner.relationship, airlineName),\n        notes\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWlybGluZS1kYXRhLWNvbnZlcnRlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRTtBQUduRTs7Q0FFQyxHQUNNLFNBQVNDLHFCQUFxQkMsV0FBbUI7SUFDdEQsSUFBSSxFQUFDQSx3QkFBQUEsa0NBQUFBLFlBQWFDLElBQUksS0FBSSxPQUFPO0lBRWpDLE1BQU1DLGFBQWFKLGlFQUFpQkEsQ0FBQ0U7SUFFckMsSUFBSSxDQUFDRSxXQUFXQyxVQUFVLElBQUlELFdBQVdFLGVBQWUsQ0FBQ0MsTUFBTSxLQUFLLEdBQUc7UUFDckUsT0FBTztJQUNUO0lBRUEsb0RBQW9EO0lBQ3BELE1BQU1DLHFCQUFxQixDQUFDQztRQUMxQixNQUFNQyxVQUFVO1lBQ2Q7WUFBcUI7WUFBbUI7WUFDeEM7WUFBc0I7WUFBbUI7U0FDMUM7UUFFRCxNQUFNQyxRQUFRO1lBQ1o7WUFBUztZQUFnQjtZQUFhO1NBQ3ZDO1FBRUQsTUFBTUMsVUFBVTtZQUNkO1lBQVc7WUFBVztTQUN2QjtRQUVELElBQUlGLFFBQVFHLFFBQVEsQ0FBQ0osT0FBTyxPQUFPO1FBQ25DLElBQUlFLE1BQU1HLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS04sS0FBS0ksUUFBUSxDQUFDRSxLQUFLLE9BQU87UUFDOUMsSUFBSUgsUUFBUUUsSUFBSSxDQUFDQyxDQUFBQSxJQUFLTixLQUFLSSxRQUFRLENBQUNFLEtBQUssT0FBTztRQUVoRCw2Q0FBNkM7UUFDN0MsT0FBTztJQUNUO0lBRUEsK0NBQStDO0lBQy9DLE1BQU1DLGNBQWMsQ0FBQ1A7UUFDbkIsTUFBTVEsVUFBa0M7WUFDdEMscUJBQXFCO1lBQ3JCLG1CQUFtQjtZQUNuQixtQkFBbUI7WUFDbkIsbUJBQW1CO1lBQ25CLGNBQWM7WUFDZCw0QkFBNEI7WUFDNUIsYUFBYTtZQUNiLHNCQUFzQjtZQUN0QixrQkFBa0I7WUFDbEIsWUFBWTtZQUNaLGlCQUFpQjtZQUNqQixzQkFBc0I7WUFDdEIsa0JBQWtCO1lBQ2xC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ZS1kYXRhLWNvbnZlcnRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBTUVYX1BBUlRORVJTLCBsb29rdXBBbWV4UGFydG5lciB9IGZyb20gXCIuL2FtZXgtcGFydG5lcnNcIjtcbmltcG9ydCB7IEFpcmxpbmUsIEFpcmxpbmVDYXRlZ29yeSB9IGZyb20gXCIuL2FpcmxpbmUtdHJhbnNmZXItdHlwZXNcIjtcblxuLyoqXG4gKiBDb252ZXJ0IGV4aXN0aW5nIEFtZXggcGFydG5lciBsb29rdXAgcmVzdWx0cyB0byB0aGUgbmV3IEFpcmxpbmUgc2NoZW1hIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvQWlybGluZURhdGEoYWlybGluZU5hbWU6IHN0cmluZyk6IEFpcmxpbmUgfCBudWxsIHtcbiAgaWYgKCFhaXJsaW5lTmFtZT8udHJpbSgpKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBhbWV4UmVzdWx0ID0gbG9va3VwQW1leFBhcnRuZXIoYWlybGluZU5hbWUpO1xuICBcbiAgaWYgKCFhbWV4UmVzdWx0LmlzQm9va2FibGUgfHwgYW1leFJlc3VsdC5wYXJ0bmVyUHJvZ3JhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgYWlybGluZSBjYXRlZ29yeSBiYXNlZCBvbiBuYW1lIHBhdHRlcm5zXG4gIGNvbnN0IGdldEFpcmxpbmVDYXRlZ29yeSA9IChuYW1lOiBzdHJpbmcpOiBBaXJsaW5lQ2F0ZWdvcnkgPT4ge1xuICAgIGNvbnN0IG1ham9yVVMgPSBbXG4gICAgICAnQW1lcmljYW4gQWlybGluZXMnLCAnRGVsdGEgQWlyIExpbmVzJywgJ1VuaXRlZCBBaXJsaW5lcycsIFxuICAgICAgJ1NvdXRod2VzdCBBaXJsaW5lcycsICdKZXRCbHVlIEFpcndheXMnLCAnQWxhc2thIEFpcmxpbmVzJ1xuICAgIF07XG4gICAgXG4gICAgY29uc3QgY2FyZ28gPSBbXG4gICAgICAnRmVkRXgnLCAnVVBTIEFpcmxpbmVzJywgJ0F0bGFzIEFpcicsICdLYWxpdHRhIEFpcidcbiAgICBdO1xuICAgIFxuICAgIGNvbnN0IGNoYXJ0ZXIgPSBbXG4gICAgICAnTmV0SmV0cycsICdGbGV4amV0JywgJ1Zpc3RhSmV0J1xuICAgIF07XG5cbiAgICBpZiAobWFqb3JVUy5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIFwiTWFqb3IgVVNcIjtcbiAgICBpZiAoY2FyZ28uc29tZShjID0+IG5hbWUuaW5jbHVkZXMoYykpKSByZXR1cm4gXCJDYXJnb1wiO1xuICAgIGlmIChjaGFydGVyLnNvbWUoYyA9PiBuYW1lLmluY2x1ZGVzKGMpKSkgcmV0dXJuIFwiQ2hhcnRlclwiO1xuICAgIFxuICAgIC8vIERlZmF1bHQgdG8gSW50ZXJuYXRpb25hbCBmb3IgbW9zdCBhaXJsaW5lc1xuICAgIHJldHVybiBcIkludGVybmF0aW9uYWxcIjtcbiAgfTtcblxuICAvLyBHZXQgSUFUQSBjb2RlIG1hcHBpbmcgKGJhc2ljIGltcGxlbWVudGF0aW9uKVxuICBjb25zdCBnZXRJYXRhQ29kZSA9IChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICAgIGNvbnN0IGlhdGFNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAnQW1lcmljYW4gQWlybGluZXMnOiAnQUEnLFxuICAgICAgJ0RlbHRhIEFpciBMaW5lcyc6ICdETCcsXG4gICAgICAnVW5pdGVkIEFpcmxpbmVzJzogJ1VBJyxcbiAgICAgICdCcml0aXNoIEFpcndheXMnOiAnQkEnLFxuICAgICAgJ0FpciBGcmFuY2UnOiAnQUYnLFxuICAgICAgJ0tMTSBSb3lhbCBEdXRjaCBBaXJsaW5lcyc6ICdLTCcsXG4gICAgICAnTHVmdGhhbnNhJzogJ0xIJyxcbiAgICAgICdTaW5nYXBvcmUgQWlybGluZXMnOiAnU1EnLFxuICAgICAgJ0NhdGhheSBQYWNpZmljJzogJ0NYJyxcbiAgICAgICdFbWlyYXRlcyc6ICdFSycsXG4gICAgICAnUWF0YXIgQWlyd2F5cyc6ICdRUicsXG4gICAgICAnQWxsIE5pcHBvbiBBaXJ3YXlzJzogJ05IJyxcbiAgICAgICdKYXBhbiBBaXJsaW5lcyc6ICdKTCcsXG4gICAgICAnQWlyIENhbmFkYSc6ICdBQycsXG4gICAgICAnVmlyZ2luIEF0bGFudGljJzogJ1ZTJyxcbiAgICAgICdUdXJraXNoIEFpcmxpbmVzJzogJ1RLJyxcbiAgICAgICdTd2lzcyBJbnRlcm5hdGlvbmFsIEFpciBMaW5lcyc6ICdMWCcsXG4gICAgICAnQXVzdHJpYW4gQWlybGluZXMnOiAnT1MnLFxuICAgICAgJ0JydXNzZWxzIEFpcmxpbmVzJzogJ1NOJyxcbiAgICAgICdTY2FuZGluYXZpYW4gQWlybGluZXMnOiAnU0snLFxuICAgICAgJ0Zpbm5haXInOiAnQVknLFxuICAgICAgJ0liZXJpYSc6ICdJQicsXG4gICAgICAnQWVyIExpbmd1cyc6ICdFSScsXG4gICAgICAnVEFQIEFpciBQb3J0dWdhbCc6ICdUUCcsXG4gICAgICAnTE9UIFBvbGlzaCBBaXJsaW5lcyc6ICdMTycsXG4gICAgICAnQ3plY2ggQWlybGluZXMnOiAnT0snLFxuICAgICAgJ0Nyb2F0aWEgQWlybGluZXMnOiAnT1UnLFxuICAgICAgJ0FpciBDaGluYSc6ICdDQScsXG4gICAgICAnQ2hpbmEgRWFzdGVybiBBaXJsaW5lcyc6ICdNVScsXG4gICAgICAnQ2hpbmEgU291dGhlcm4gQWlybGluZXMnOiAnQ1onLFxuICAgICAgJ0tvcmVhbiBBaXInOiAnS0UnLFxuICAgICAgJ0FzaWFuYSBBaXJsaW5lcyc6ICdPWicsXG4gICAgICAnVGhhaSBBaXJ3YXlzJzogJ1RHJyxcbiAgICAgICdNYWxheXNpYSBBaXJsaW5lcyc6ICdNSCcsXG4gICAgICAnR2FydWRhIEluZG9uZXNpYSc6ICdHQScsXG4gICAgICAnUGhpbGlwcGluZSBBaXJsaW5lcyc6ICdQUicsXG4gICAgICAnVmlldG5hbSBBaXJsaW5lcyc6ICdWTicsXG4gICAgICAnQWlyIEluZGlhJzogJ0FJJyxcbiAgICAgICdFdGhpb3BpYW4gQWlybGluZXMnOiAnRVQnLFxuICAgICAgJ0tlbnlhIEFpcndheXMnOiAnS1EnLFxuICAgICAgJ1NvdXRoIEFmcmljYW4gQWlyd2F5cyc6ICdTQScsXG4gICAgICAnRWd5cHRBaXInOiAnTVMnLFxuICAgICAgJ1JveWFsIEFpciBNYXJvYyc6ICdBVCcsXG4gICAgICAnUm95YWwgSm9yZGFuaWFuJzogJ1JKJyxcbiAgICAgICdNaWRkbGUgRWFzdCBBaXJsaW5lcyc6ICdNRScsXG4gICAgICAnU2F1ZGlhJzogJ1NWJyxcbiAgICAgICdFdGloYWQgQWlyd2F5cyc6ICdFWScsXG4gICAgICAnT21hbiBBaXInOiAnV1knLFxuICAgICAgJ0t1d2FpdCBBaXJ3YXlzJzogJ0tVJyxcbiAgICAgICdKZXRCbHVlIEFpcndheXMnOiAnQjYnLFxuICAgICAgJ0FsYXNrYSBBaXJsaW5lcyc6ICdBUycsXG4gICAgICAnSGF3YWlpYW4gQWlybGluZXMnOiAnSEEnLFxuICAgICAgJ1NvdXRod2VzdCBBaXJsaW5lcyc6ICdXTicsXG4gICAgICAnRnJvbnRpZXIgQWlybGluZXMnOiAnRjknLFxuICAgICAgJ1NwaXJpdCBBaXJsaW5lcyc6ICdOSycsXG4gICAgICAnQWxsZWdpYW50IEFpcic6ICdHNCcsXG4gICAgICAnU3VuIENvdW50cnkgQWlybGluZXMnOiAnU1knLFxuICAgICAgJ1FhbnRhcyc6ICdRRicsXG4gICAgICAnVmlyZ2luIEF1c3RyYWxpYSc6ICdWQScsXG4gICAgICAnQWlyIE5ldyBaZWFsYW5kJzogJ05aJyxcbiAgICAgICdBdmlhbmNhJzogJ0FWJyxcbiAgICAgICdMQVRBTSBBaXJsaW5lcyc6ICdMQScsXG4gICAgICAnQ29wYSBBaXJsaW5lcyc6ICdDTScsXG4gICAgICAnQWVyb21leGljbyc6ICdBTScsXG4gICAgICAnV2VzdEpldCc6ICdXUydcbiAgICB9O1xuICAgIHJldHVybiBpYXRhTWFwW25hbWVdO1xuICB9O1xuXG4gIC8vIEZpbmQgdGhlIHByZWZlcnJlZCBwYXJ0bmVyIChwcmlvcml0aXplIERpcmVjdCA+IEFsbGlhbmNlID4gQmlsYXRlcmFsKVxuICBjb25zdCBzb3J0ZWRQYXJ0bmVycyA9IFsuLi5hbWV4UmVzdWx0LnBhcnRuZXJQcm9ncmFtc10uc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHByaW9yaXR5ID0geyAnRGlyZWN0JzogMCwgJ0FsbGlhbmNlJzogMSwgJ0JpbGF0ZXJhbCc6IDIgfTtcbiAgICByZXR1cm4gcHJpb3JpdHlbYS5yZWxhdGlvbnNoaXBdIC0gcHJpb3JpdHlbYi5yZWxhdGlvbnNoaXBdO1xuICB9KTtcblxuICBjb25zdCBwcmVmZXJyZWRQYXJ0bmVyID0gc29ydGVkUGFydG5lcnNbMF07XG4gIGNvbnN0IGlzRGlyZWN0UGFydG5lciA9IHByZWZlcnJlZFBhcnRuZXIucmVsYXRpb25zaGlwID09PSAnRGlyZWN0JztcblxuICAvLyBHZW5lcmF0ZSBob3ctdG8tYm9vayBzdGVwcyBiYXNlZCBvbiB0aGUgcGFydG5lciB0eXBlXG4gIGNvbnN0IGdlbmVyYXRlQm9va2luZ1N0ZXBzID0gKHBhcnRuZXJOYW1lOiBzdHJpbmcsIHJlbGF0aW9uc2hpcDogc3RyaW5nLCBhaXJsaW5lTmFtZTogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IGJhc2VTdGVwcyA9IFtcbiAgICAgIGBUcmFuc2ZlciBBbWV4IHBvaW50cyB0byAke3BhcnRuZXJOYW1lfSBhdCAke3ByZWZlcnJlZFBhcnRuZXIudHJhbnNmZXJSYXRpb30gcmF0aW9gLFxuICAgICAgYFdhaXQgZm9yIHRyYW5zZmVyIHRvIGNvbXBsZXRlICgke3ByZWZlcnJlZFBhcnRuZXIudHJhbnNmZXJUaW1lfSlgLFxuICAgICAgYExvZyBpbnRvIHlvdXIgJHtwYXJ0bmVyTmFtZX0gYWNjb3VudGBcbiAgICBdO1xuXG4gICAgaWYgKHJlbGF0aW9uc2hpcCA9PT0gJ0RpcmVjdCcpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLmJhc2VTdGVwcyxcbiAgICAgICAgYFNlYXJjaCBmb3IgJHthaXJsaW5lTmFtZX0gZmxpZ2h0cyBvbiB0aGUgJHtwYXJ0bmVyTmFtZX0gd2Vic2l0ZWAsXG4gICAgICAgIGBCb29rIHVzaW5nIHBvaW50cyBhbmQgcGF5IGFueSB0YXhlcy9mZWVzIHdpdGggY2FzaGBcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChyZWxhdGlvbnNoaXAgPT09ICdBbGxpYW5jZScpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC4uLmJhc2VTdGVwcyxcbiAgICAgICAgYFNlYXJjaCBmb3IgJHthaXJsaW5lTmFtZX0gZmxpZ2h0cyAoYWxsaWFuY2UgcGFydG5lcikgb24gdGhlICR7cGFydG5lck5hbWV9IHdlYnNpdGVgLFxuICAgICAgICBgQm9vayB0aGUgYXdhcmQgdGlja2V0IHVzaW5nIHBvaW50c2AsXG4gICAgICAgIGBQYXkgdGF4ZXMgYW5kIGZlZXMgd2l0aCBjYXNoIChtYXkgYmUgaGlnaGVyIGZvciBwYXJ0bmVyIGF3YXJkcylgXG4gICAgICBdO1xuICAgIH0gZWxzZSB7IC8vIEJpbGF0ZXJhbFxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4uYmFzZVN0ZXBzLFxuICAgICAgICBgU2VhcmNoIGZvciAke2FpcmxpbmVOYW1lfSBmbGlnaHRzIG9uIHRoZSAke3BhcnRuZXJOYW1lfSB3ZWJzaXRlYCxcbiAgICAgICAgYExvb2sgZm9yIHBhcnRuZXIgYXdhcmQgYXZhaWxhYmlsaXR5IChtYXkgYmUgbGltaXRlZClgLFxuICAgICAgICBgQm9vayB1c2luZyBwb2ludHMgYW5kIHBheSB0YXhlcy9mZWVzIHdpdGggY2FzaGBcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8vIEdlbmVyYXRlIG5vdGVzIGJhc2VkIG9uIGNvbW1vbiBwYXR0ZXJuc1xuICBjb25zdCBnZW5lcmF0ZU5vdGVzID0gKHBhcnRuZXJOYW1lOiBzdHJpbmcsIHJlbGF0aW9uc2hpcDogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xuICAgIGNvbnN0IG5vdGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmIChyZWxhdGlvbnNoaXAgPT09ICdBbGxpYW5jZScpIHtcbiAgICAgIG5vdGVzLnB1c2goXCJBbGxpYW5jZSBwYXJ0bmVyIGJvb2tpbmdzIG1heSBoYXZlIGxpbWl0ZWQgYXdhcmQgYXZhaWxhYmlsaXR5XCIpO1xuICAgICAgbm90ZXMucHVzaChcIkV4cGVjdCBoaWdoZXIgdGF4ZXMgYW5kIGZlZXMgY29tcGFyZWQgdG8gZGlyZWN0IHBhcnRuZXIgYm9va2luZ3NcIik7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZWxhdGlvbnNoaXAgPT09ICdCaWxhdGVyYWwnKSB7XG4gICAgICBub3Rlcy5wdXNoKFwiQmlsYXRlcmFsIHBhcnRuZXJzaGlwIG1heSBoYXZlIHJlc3RyaWN0ZWQgcm91dGVzIGFuZCBhdmFpbGFiaWxpdHlcIik7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRuZXJOYW1lLmluY2x1ZGVzKCdCcml0aXNoIEFpcndheXMnKSkge1xuICAgICAgbm90ZXMucHVzaChcIkJyaXRpc2ggQWlyd2F5cyB1c2VzIGRpc3RhbmNlLWJhc2VkIHByaWNpbmcgLSBleGNlbGxlbnQgZm9yIHNob3J0IGZsaWdodHNcIik7XG4gICAgICBub3Rlcy5wdXNoKFwiTG93IHRheGVzIGFuZCBmZWVzIG9uIGRvbWVzdGljIFVTIGZsaWdodHNcIik7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRuZXJOYW1lLmluY2x1ZGVzKCdBaXIgRnJhbmNlJykgfHwgcGFydG5lck5hbWUuaW5jbHVkZXMoJ0tMTScpKSB7XG4gICAgICBub3Rlcy5wdXNoKFwiRmx5aW5nIEJsdWUgaGFzIGR5bmFtaWMgcHJpY2luZyAtIGJvb2sgZWFybHkgZm9yIGJldHRlciByYXRlc1wiKTtcbiAgICB9XG5cbiAgICBpZiAocGFydG5lck5hbWUuaW5jbHVkZXMoJ1NpbmdhcG9yZSBBaXJsaW5lcycpKSB7XG4gICAgICBub3Rlcy5wdXNoKFwiS3Jpc0ZseWVyIGhhcyBleGNlbGxlbnQgcHJlbWl1bSBjYWJpbiBhdmFpbGFiaWxpdHlcIik7XG4gICAgfVxuXG4gICAgaWYgKG5vdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbm90ZXMucHVzaChcIkJvb2sgd2VsbCBpbiBhZHZhbmNlIGZvciBiZXR0ZXIgYXdhcmQgYXZhaWxhYmlsaXR5XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub3RlcztcbiAgfTtcblxuICBjb25zdCBib29rYWJsZVZpYSA9IGFtZXhSZXN1bHQucGFydG5lclByb2dyYW1zLm1hcChwID0+IHAucGFydG5lck5hbWUpO1xuICBjb25zdCBwYXJ0bmVyRGV0YWlscyA9IGFtZXhSZXN1bHQucGFydG5lclByb2dyYW1zLm1hcChwID0+ICh7XG4gICAgbmFtZTogcC5wYXJ0bmVyTmFtZSxcbiAgICByZWxhdGlvbnNoaXA6IHAucmVsYXRpb25zaGlwLFxuICAgIHRyYW5zZmVyUmF0aW86IHAudHJhbnNmZXJSYXRpbyxcbiAgICB0cmFuc2ZlclRpbWU6IHAudHJhbnNmZXJUaW1lXG4gIH0pKTtcbiAgY29uc3Qgbm90ZXMgPSBnZW5lcmF0ZU5vdGVzKHByZWZlcnJlZFBhcnRuZXIucGFydG5lck5hbWUsIHByZWZlcnJlZFBhcnRuZXIucmVsYXRpb25zaGlwKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGFpcmxpbmVOYW1lLFxuICAgIGlhdGFDb2RlOiBnZXRJYXRhQ29kZShhaXJsaW5lTmFtZSksXG4gICAgY2F0ZWdvcnk6IGdldEFpcmxpbmVDYXRlZ29yeShhaXJsaW5lTmFtZSksXG4gICAgaXNEaXJlY3RQYXJ0bmVyLFxuICAgIGlzQWxsaWFuY2VCb29rYWJsZTogYW1leFJlc3VsdC5wYXJ0bmVyUHJvZ3JhbXMuc29tZShwID0+IHAucmVsYXRpb25zaGlwID09PSAnQWxsaWFuY2UnKSxcbiAgICBpc0JpbGF0ZXJhbEJvb2thYmxlOiBhbWV4UmVzdWx0LnBhcnRuZXJQcm9ncmFtcy5zb21lKHAgPT4gcC5yZWxhdGlvbnNoaXAgPT09ICdCaWxhdGVyYWwnKSxcbiAgICBib29rYWJsZVZpYSxcbiAgICBwYXJ0bmVyRGV0YWlscyxcbiAgICBwcmVmZXJyZWRQYXJ0bmVyOiBwcmVmZXJyZWRQYXJ0bmVyLnBhcnRuZXJOYW1lLFxuICAgIHRyYW5zZmVyUmF0aW86IHByZWZlcnJlZFBhcnRuZXIudHJhbnNmZXJSYXRpbyxcbiAgICB0cmFuc2ZlclRpbWU6IHByZWZlcnJlZFBhcnRuZXIudHJhbnNmZXJUaW1lLFxuICAgIGhvd1RvQm9va1N0ZXBzOiBnZW5lcmF0ZUJvb2tpbmdTdGVwcyhwcmVmZXJyZWRQYXJ0bmVyLnBhcnRuZXJOYW1lLCBwcmVmZXJyZWRQYXJ0bmVyLnJlbGF0aW9uc2hpcCwgYWlybGluZU5hbWUpLFxuICAgIG5vdGVzXG4gIH07XG59XG4iXSwibmFtZXMiOlsibG9va3VwQW1leFBhcnRuZXIiLCJjb252ZXJ0VG9BaXJsaW5lRGF0YSIsImFpcmxpbmVOYW1lIiwidHJpbSIsImFtZXhSZXN1bHQiLCJpc0Jvb2thYmxlIiwicGFydG5lclByb2dyYW1zIiwibGVuZ3RoIiwiZ2V0QWlybGluZUNhdGVnb3J5IiwibmFtZSIsIm1ham9yVVMiLCJjYXJnbyIsImNoYXJ0ZXIiLCJpbmNsdWRlcyIsInNvbWUiLCJjIiwiZ2V0SWF0YUNvZGUiLCJpYXRhTWFwIiwic29ydGVkUGFydG5lcnMiLCJzb3J0IiwiYSIsImIiLCJwcmlvcml0eSIsInJlbGF0aW9uc2hpcCIsInByZWZlcnJlZFBhcnRuZXIiLCJpc0RpcmVjdFBhcnRuZXIiLCJnZW5lcmF0ZUJvb2tpbmdTdGVwcyIsInBhcnRuZXJOYW1lIiwiYmFzZVN0ZXBzIiwidHJhbnNmZXJSYXRpbyIsInRyYW5zZmVyVGltZSIsImdlbmVyYXRlTm90ZXMiLCJub3RlcyIsInB1c2giLCJib29rYWJsZVZpYSIsIm1hcCIsInAiLCJwYXJ0bmVyRGV0YWlscyIsImlhdGFDb2RlIiwiY2F0ZWdvcnkiLCJpc0FsbGlhbmNlQm9va2FibGUiLCJpc0JpbGF0ZXJhbEJvb2thYmxlIiwiaG93VG9Cb29rU3RlcHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/airline-data-converter.ts\n"));

/***/ })

});